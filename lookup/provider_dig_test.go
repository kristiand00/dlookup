package lookup_test

import (
	"dlookup/lookup"
	"fmt"
	"strings"
	"testing"
)

var digProviderTestCases = []struct {
	name         string
	expectedName string
	expectedFlag string
	digArgs      []string // These are the args specific to the provider type, not including domain
}{
	// Corrected expectedFlag to include the "dig-" prefix generated by newDigProvider
	{"DIG (ANY)", "DIG (ANY)", "dig-dig-any", []string{"ANY", "+noall", "+answer"}},
	{"DIG (A)", "DIG (A)", "dig-dig-a", []string{"A", "+short"}},
	{"DIG (AAAA)", "DIG (AAAA)", "dig-dig-aaaa", []string{"AAAA", "+short"}},
	{"DIG (MX)", "DIG (MX)", "dig-dig-mx", []string{"MX", "+short"}},
	{"DIG (TXT)", "DIG (TXT)", "dig-dig-txt", []string{"TXT", "+noall", "+answer"}},
	{"DIG (SOA)", "DIG (SOA)", "dig-dig-soa", []string{"SOA", "+noall", "+answer"}},
	{"DIG (CNAME)", "DIG (CNAME)", "dig-dig-cname", []string{"CNAME", "+short"}},
}

func TestDigProviders_StaticMethods(t *testing.T) {
	for _, tc := range digProviderTestCases {
		t.Run(tc.name, func(t *testing.T) {
			provider, ok := lookup.GetProvider(tc.name)
			if !ok {
				t.Fatalf("Expected provider %q not found.", tc.name)
			}

			if name := provider.Name(); name != tc.expectedName {
				t.Errorf("Name() = %q, want %q", name, tc.expectedName)
			}

			if flagName := provider.FlagName(); flagName != tc.expectedFlag {
				t.Errorf("FlagName() = %q, want %q", flagName, tc.expectedFlag)
			}

			expectedUsagePrefix := fmt.Sprintf("Run %s", tc.expectedName)
			expectedUsageSuffix := "lookup on domains from <filename>"
			if usage := provider.Usage(); !strings.HasPrefix(usage, expectedUsagePrefix) || !strings.HasSuffix(usage, expectedUsageSuffix) {
				t.Errorf("Usage() = %q, want prefix %q and suffix %q", usage, expectedUsagePrefix, expectedUsageSuffix)
			}
		})
	}
}

func TestDigProviders_CheckAvailability(t *testing.T) {
	origCheckCommandFunc := lookup.LookupCheckCommandFunc
	defer func() { lookup.LookupCheckCommandFunc = origCheckCommandFunc }()
	lookup.LookupCheckCommandFunc = func(cmd string) bool {
		return cmd == "dig" // Assume dig is always available for these tests
	}

	for _, tc := range digProviderTestCases {
		t.Run(tc.name, func(t *testing.T) {
			provider, ok := lookup.GetProvider(tc.name)
			if !ok {
				t.Fatalf("Expected provider %q not found.", tc.name)
			}

			// This test assumes 'dig' command is available in the test environment's PATH.
			// If 'dig' is not available, this test will fail, which is the correct behavior,
			// as CheckAvailability for DigProvider relies on checkCommand("dig").
			if !provider.CheckAvailability() {
				t.Errorf("CheckAvailability() for %q returned false, expected true (assuming 'dig' is available).", tc.name)
			}
		})
	}
}

// equalSlices is a helper to compare two string slices.
// This can be moved to a common test utility if needed elsewhere.
func equalSlices(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func TestDigProviders_Execute(t *testing.T) {
	origRunCommand := lookup.OsRunCommand
	defer func() { lookup.OsRunCommand = origRunCommand }()

	origCheckCommandFunc := lookup.LookupCheckCommandFunc
	defer func() { lookup.LookupCheckCommandFunc = origCheckCommandFunc }()
	lookup.LookupCheckCommandFunc = func(cmd string) bool {
		return cmd == "dig" // Assume dig is always available for Execute tests
	}

	var capturedCmdName string
	var capturedArgs []string

	for _, tc := range digProviderTestCases {
		t.Run(tc.name, func(t *testing.T) {
			provider, ok := lookup.GetProvider(tc.name)
			if !ok {
				t.Fatalf("Expected provider %q not found.", tc.name)
			}

			// Test Case 1: Successful execution
			t.Run("Success", func(t *testing.T) {
				expectedOutput := "mocked_dig_output_for_" + tc.name
				lookup.OsRunCommand = func(cmdName string, args ...string) (string, error) {
					capturedCmdName = cmdName
					capturedArgs = args
					return expectedOutput, nil
				}

				output, err := provider.Execute("testdomain.com")
				if err != nil {
					t.Errorf("Execute() error = %v, want nil", err)
				}
				if output != expectedOutput {
					t.Errorf("Execute() output = %q, want %q", output, expectedOutput)
				}
				if capturedCmdName != "dig" {
					t.Errorf("Execute() called command %q, want 'dig'", capturedCmdName)
				}

				expectedCmdArgs := append([]string{"testdomain.com"}, tc.digArgs...)
				if !equalSlices(capturedArgs, expectedCmdArgs) {
					t.Errorf("Execute() args = %v, want %v", capturedArgs, expectedCmdArgs)
				}
			})

			// Test Case 2: Command execution failure
			t.Run("CommandFailure", func(t *testing.T) {
				// This is the error our mock OsRunCommand will return
				mockError := fmt.Errorf("mocked dig error for %s", tc.name)

				lookup.OsRunCommand = func(cmdName string, args ...string) (string, error) {
					capturedCmdName = cmdName
					capturedArgs = args
					// lookup.RunCommand wraps the error from OsRunCommand.
					// It returns: fmt.Errorf("command '%s %s' failed: %w", cmdName, strings.Join(args, " "), err)
					// So, the error we get from provider.Execute() will be this wrapped error.
					return "error output", mockError // "error output" could be potential stderr
				}

				output, err := provider.Execute("testdomain.com")
				if err == nil {
					t.Fatalf("Execute() error = nil, want non-nil")
				}

				// Check that the error message contains the mockError.Error() string.
				// Now RunCommand performs the wrapping.
				expectedWrappedErrStr := fmt.Sprintf("command 'dig %s' failed: %s", strings.Join(append([]string{"testdomain.com"}, tc.digArgs...), " "), mockError.Error())
				if err == nil {
					t.Fatalf("Execute() error = nil, want non-nil")
				} else if err.Error() != expectedWrappedErrStr {
					t.Errorf("Execute() error = %q, want %q", err.Error(), expectedWrappedErrStr)
				}

				// Also check the output, which might contain stderr if RunCommand populates it.
				// The mock OsRunCommand returns "error output" as the string part.
				if output != "error output" {
					t.Errorf("Execute() output on error = %q, want %q", output, "error output")
				}
			})

			// Test Case 3: Command produces no output (but no error)
			t.Run("NoOutput", func(t *testing.T) {
				// RunCommand should convert empty raw output to "(No results found)"
				expectedOutput := "(No results found)"
				lookup.OsRunCommand = func(cmdName string, args ...string) (string, error) {
					capturedCmdName = cmdName
					capturedArgs = args
					return "", nil // Mock OsRunCommand returns empty string and nil error
				}

				output, err := provider.Execute("nodata.example.com")
				if err != nil {
					t.Errorf("Execute() error = %v, want nil", err)
				}
				if output != expectedOutput {
					t.Errorf("Execute() output = %q, want %q", output, expectedOutput)
				}
			})
		})
	}
}
